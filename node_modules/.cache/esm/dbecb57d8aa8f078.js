let Joi,JwtService,CustomErrorHandler,User,RefToken,bcrypt,JWT_REF_SECRET;_8aa‍.x([["default",()=>_8aa‍.o]]);_8aa‍.w("joi",[["default",["Joi"],function(v){Joi=v}]]);_8aa‍.w("../../services.js",[["JwtService",["JwtService"],function(v){JwtService=v}],["CustomErrorHandler",["CustomErrorHandler"],function(v){CustomErrorHandler=v}]]);_8aa‍.w("../../models",[["User",["User"],function(v){User=v}],["RefToken",["RefToken"],function(v){RefToken=v}]]);_8aa‍.w("bcrypt",[["default",["bcrypt"],function(v){bcrypt=v}]]);_8aa‍.w("../../config",[["JWT_REF_SECRET",["JWT_REF_SECRET"],function(v){JWT_REF_SECRET=v}]]);





const logoutController = {
  async logout(req, res, next) {
    // validation
    const loginSchema = Joi.object({
      email: Joi.string().email().required(),
      password: Joi.string().required(),
    });

    const { error } = loginSchema.validate(req.body);

    if (error) {
      return next(error);
    }

    const { email, password } = req.body;

    try {
      const user = await User.findOne({ email });

      if (!user) {
        return next(CustomErrorHandler.invalidCredentials());
      }

      const match = await bcrypt.compare(password, user.password);

      if (!match) {
        return next(CustomErrorHandler.invalidCredentials());
      }

      const _id = user._id;

      const accessToken = JwtService.sign({ _id });
      const refToken = JwtService.sign({ _id }, "1y", JWT_REF_SECRET);

      await RefToken.create({ refToken });


      res.json({ accessToken, refToken });
    } catch (err) {
      return next(err);
    }
  },
};

_8aa‍.d(logoutController);
